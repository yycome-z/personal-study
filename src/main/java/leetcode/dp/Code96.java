package main.java.leetcode.dp;

/**
 * 不同的二叉搜索树
 *
 * 给你一个整数 n，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的二叉搜索树有多少种？返回满足题意的二叉搜索树的种数。
 *
 * 输入：n = 3
 * 输出：5
 *
 * 1 <= n <= 19
 *
 * @author zhangyaoyuan
 * @date 2023/09/12
 */
public class Code96 {

    /**
     * 确定状态转移方程：
     *如果想构造的二叉搜索树树的根节点值为 i，根据二叉搜索树的性质，这棵二叉搜索树左子树是值（1 ~ i- 1），右子树值是（i + 1~n）。
     * 对于根节点值为 i 的二叉搜索树而言，根节点已经确定，则有多少种不同的二叉搜索树取决于左子树和右子树能组成多少种。
     * dp[i] 的状态定义为：一共 i 个节点可以组成不同二叉搜索树的种数。
     * 则对于左子树，它可以构成不同的二叉搜索树的种类为 dp[i - 1]。
     * 对于右子树，它可以构成不同的二叉搜索树的种类为 dp[n - i]。
     * 假设 f[i] 表示为“根节点值为 i，可以组成不同二叉搜索树的种数”，那么：
     * f[i] = dp[i - 1] * dp[n - i]（公式 1）
     *
     * 那么对于构造总共有 n 个节点的二叉搜索树来说，它等于“根节点为 1 可以组成的种数 + 根节点为 2 可以组成的种数 + ... + 根节点为 n 可以组成的种数”，即：
     * dp[n] = f[1] + f[2] + ... + f[i] + ... + f[n] （公式 2）
     *
     * @param n
     * @return
     */
    public int numTrees(int n) {
        if (n < 3) {
            return n;
        }
        // dp[i]表示节点数为i时可组成的搜索二叉树的个数
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;

        for (int i = 3; i < n + 1; i++) {
            for (int j = 1; j < i + 1; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }

        return dp[n];
    }
}
